// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace UiPath.Web.Client20204.Models
{
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using System.Runtime;
    using System.Runtime.Serialization;

    /// <summary>
    /// Defines values for FailedQueueItemDtoErrorCode.
    /// </summary>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum FailedQueueItemDtoErrorCode
    {
        [EnumMember(Value = "Unknown")]
        Unknown,
        [EnumMember(Value = "MultipleErrors")]
        MultipleErrors,
        [EnumMember(Value = "InvalidRequest")]
        InvalidRequest,
        [EnumMember(Value = "NameAlreadyUsed")]
        NameAlreadyUsed,
        [EnumMember(Value = "ItemNotFound")]
        ItemNotFound,
        [EnumMember(Value = "StringProtectFailed")]
        StringProtectFailed,
        [EnumMember(Value = "ItemAlreadyExists")]
        ItemAlreadyExists,
        [EnumMember(Value = "ErrorDeleting")]
        ErrorDeleting,
        [EnumMember(Value = "ErrorInserting")]
        ErrorInserting,
        [EnumMember(Value = "ErrorUpdating")]
        ErrorUpdating,
        [EnumMember(Value = "ErrorSendingEmail")]
        ErrorSendingEmail,
        [EnumMember(Value = "InvalidArgument")]
        InvalidArgument,
        [EnumMember(Value = "SqlAcquireLockFailure")]
        SqlAcquireLockFailure,
        [EnumMember(Value = "LibrariesFeedInUse")]
        LibrariesFeedInUse,
        [EnumMember(Value = "HasDependentItems")]
        HasDependentItems,
        [EnumMember(Value = "ItemIsInUse")]
        ItemIsInUse,
        [EnumMember(Value = "ParameterMissing")]
        ParameterMissing,
        [EnumMember(Value = "ParameterInvalid")]
        ParameterInvalid,
        [EnumMember(Value = "DuplicateReference")]
        DuplicateReference,
        [EnumMember(Value = "ForbiddenOperation")]
        ForbiddenOperation,
        [EnumMember(Value = "InvalidUser")]
        InvalidUser,
        [EnumMember(Value = "FeatureDisabled")]
        FeatureDisabled,
        [EnumMember(Value = "OptimisticConcurrency")]
        OptimisticConcurrency,
        [EnumMember(Value = "EncryptionException")]
        EncryptionException,
        [EnumMember(Value = "CannotCreateOrMigrateTenantDb")]
        CannotCreateOrMigrateTenantDb,
        [EnumMember(Value = "TenantIsRequired")]
        TenantIsRequired,
        [EnumMember(Value = "FieldNotEditable")]
        FieldNotEditable,
        [EnumMember(Value = "ServiceUnavailable")]
        ServiceUnavailable,
        [EnumMember(Value = "SharedAccessSignatureFailure")]
        SharedAccessSignatureFailure,
        [EnumMember(Value = "ProviderNotSupported")]
        ProviderNotSupported,
        [EnumMember(Value = "InvalidAuditRelationship")]
        InvalidAuditRelationship,
        [EnumMember(Value = "InvalidOrganizationUnit")]
        InvalidOrganizationUnit,
        [EnumMember(Value = "RequiredOrganizationUnit")]
        RequiredOrganizationUnit,
        [EnumMember(Value = "OrganizationUnitNotEditable")]
        OrganizationUnitNotEditable,
        [EnumMember(Value = "MachineAlreadyPairedWithDifferentLicenseKey")]
        MachineAlreadyPairedWithDifferentLicenseKey,
        [EnumMember(Value = "NoAvailableLicenses")]
        NoAvailableLicenses,
        [EnumMember(Value = "HasAttachedRobots")]
        HasAttachedRobots,
        [EnumMember(Value = "InvalidMachineKey")]
        InvalidMachineKey,
        [EnumMember(Value = "MachineNameRequired")]
        MachineNameRequired,
        [EnumMember(Value = "UserNameRequired")]
        UserNameRequired,
        [EnumMember(Value = "CannotDeleteBusyRobot")]
        CannotDeleteBusyRobot,
        [EnumMember(Value = "MachineNameCannotChange")]
        MachineNameCannotChange,
        [EnumMember(Value = "MachineLicenseCannotChange")]
        MachineLicenseCannotChange,
        [EnumMember(Value = "CannotUpdateBusyRobot")]
        CannotUpdateBusyRobot,
        [EnumMember(Value = "MachineTypeCannotChange")]
        MachineTypeCannotChange,
        [EnumMember(Value = "UserNameInvalid")]
        UserNameInvalid,
        [EnumMember(Value = "SessionAlreadyActive")]
        SessionAlreadyActive,
        [EnumMember(Value = "CannotAssignMachineToFloatingRobot")]
        CannotAssignMachineToFloatingRobot,
        [EnumMember(Value = "CannotUpdateRobotHostingType")]
        CannotUpdateRobotHostingType,
        [EnumMember(Value = "CannotAssignMachineTemplateToStandardRobot")]
        CannotAssignMachineTemplateToStandardRobot,
        [EnumMember(Value = "CannotUpdateActiveSession")]
        CannotUpdateActiveSession,
        [EnumMember(Value = "MachineTemplateUniqueLicenseKey")]
        MachineTemplateUniqueLicenseKey,
        [EnumMember(Value = "InvalidMachineId")]
        InvalidMachineId,
        [EnumMember(Value = "InvalidNonProductionMachineSlots")]
        InvalidNonProductionMachineSlots,
        [EnumMember(Value = "InvalidUnattendedMachineSlots")]
        InvalidUnattendedMachineSlots,
        [EnumMember(Value = "DisconnectedRobot")]
        DisconnectedRobot,
        [EnumMember(Value = "UnresponsiveRobot")]
        UnresponsiveRobot,
        [EnumMember(Value = "UnsupportedFloatingSessionRobotType")]
        UnsupportedFloatingSessionRobotType,
        [EnumMember(Value = "UnsupportedStandardSessionRobotType")]
        UnsupportedStandardSessionRobotType,
        [EnumMember(Value = "EnvironmentDeploymentConflict")]
        EnvironmentDeploymentConflict,
        [EnumMember(Value = "ServerConflict")]
        ServerConflict,
        [EnumMember(Value = "ActionAlreadyPerformed")]
        ActionAlreadyPerformed,
        [EnumMember(Value = "UnavailableResources")]
        UnavailableResources,
        [EnumMember(Value = "UserIsDeleted")]
        UserIsDeleted,
        [EnumMember(Value = "UserIsLockedOut")]
        UserIsLockedOut,
        [EnumMember(Value = "ChangePassword")]
        ChangePassword,
        [EnumMember(Value = "PasswordExpired")]
        PasswordExpired,
        [EnumMember(Value = "InvalidPassword")]
        InvalidPassword,
        [EnumMember(Value = "CannotDeleteStaticRole")]
        CannotDeleteStaticRole,
        [EnumMember(Value = "UserNotEditable")]
        UserNotEditable,
        [EnumMember(Value = "DomainUnreachable")]
        DomainUnreachable,
        [EnumMember(Value = "PasswordResetFailed")]
        PasswordResetFailed,
        [EnumMember(Value = "ConfirmEmailFailed")]
        ConfirmEmailFailed,
        [EnumMember(Value = "CannotUsePreviousPassword")]
        CannotUsePreviousPassword,
        [EnumMember(Value = "RoleIsNotEditable")]
        RoleIsNotEditable,
        [EnumMember(Value = "UserNotFoundInDomain")]
        UserNotFoundInDomain,
        [EnumMember(Value = "CannotUpdateUsername")]
        CannotUpdateUsername,
        [EnumMember(Value = "InvalidLoginMethod")]
        InvalidLoginMethod,
        [EnumMember(Value = "InvalidUsernameOrPassword")]
        InvalidUsernameOrPassword,
        [EnumMember(Value = "MultipleMatchingUsers")]
        MultipleMatchingUsers,
        [EnumMember(Value = "CannotCallFromHost")]
        CannotCallFromHost,
        [EnumMember(Value = "CreateNotAllowed")]
        CreateNotAllowed,
        [EnumMember(Value = "ProvisionError")]
        ProvisionError,
        [EnumMember(Value = "EmptyDomainOrUsername")]
        EmptyDomainOrUsername,
        [EnumMember(Value = "NotDirectoryUserOrGroup")]
        NotDirectoryUserOrGroup,
        [EnumMember(Value = "CredentialAssetEmptyPasswordForNewUser")]
        CredentialAssetEmptyPasswordForNewUser,
        [EnumMember(Value = "CredentialAssetEmptyForNewRobot")]
        CredentialAssetEmptyForNewRobot,
        [EnumMember(Value = "AssetTypeNonUpdatable")]
        AssetTypeNonUpdatable,
        [EnumMember(Value = "AssetNotAvailableForRobot")]
        AssetNotAvailableForRobot,
        [EnumMember(Value = "InvalidCron")]
        InvalidCron,
        [EnumMember(Value = "ScheduleWillNeverRun")]
        ScheduleWillNeverRun,
        [EnumMember(Value = "ScheduleMisfired")]
        ScheduleMisfired,
        [EnumMember(Value = "ScheduleInvalidTimeZone")]
        ScheduleInvalidTimeZone,
        [EnumMember(Value = "InvalidScheduleKey")]
        InvalidScheduleKey,
        [EnumMember(Value = "ScheduleIsNotEnabled")]
        ScheduleIsNotEnabled,
        [EnumMember(Value = "ScheduleNotAssociatedWithAQueue")]
        ScheduleNotAssociatedWithAQueue,
        [EnumMember(Value = "ScheduleCannotBeAssociatedWithAQueue")]
        ScheduleCannotBeAssociatedWithAQueue,
        [EnumMember(Value = "UserIsAssignedToTriggers")]
        UserIsAssignedToTriggers,
        [EnumMember(Value = "DownloadUnavailable")]
        DownloadUnavailable,
        [EnumMember(Value = "CannotConnectToPackagesRepository")]
        CannotConnectToPackagesRepository,
        [EnumMember(Value = "NotSupportedByExternalFeeds")]
        NotSupportedByExternalFeeds,
        [EnumMember(Value = "ErrorDownloading")]
        ErrorDownloading,
        [EnumMember(Value = "InvalidPackageDetails")]
        InvalidPackageDetails,
        [EnumMember(Value = "TenantFeedInUse")]
        TenantFeedInUse,
        [EnumMember(Value = "InvalidProcessKey")]
        InvalidProcessKey,
        [EnumMember(Value = "JobTypeCannotBeStopped")]
        JobTypeCannotBeStopped,
        [EnumMember(Value = "JobCannotBeCancelled")]
        JobCannotBeCancelled,
        [EnumMember(Value = "JobCannotBeTerminated")]
        JobCannotBeTerminated,
        [EnumMember(Value = "VersionNotFound")]
        VersionNotFound,
        [EnumMember(Value = "ProcessNotFound")]
        ProcessNotFound,
        [EnumMember(Value = "HasAttachedProcesses")]
        HasAttachedProcesses,
        [EnumMember(Value = "InvalidExtension")]
        InvalidExtension,
        [EnumMember(Value = "InvalidPackageCount")]
        InvalidPackageCount,
        [EnumMember(Value = "PreviousVersionNotFound")]
        PreviousVersionNotFound,
        [EnumMember(Value = "HasRunningJobs")]
        HasRunningJobs,
        [EnumMember(Value = "TenantNotFound")]
        TenantNotFound,
        [EnumMember(Value = "PendingJobsAlreadyExist")]
        PendingJobsAlreadyExist,
        [EnumMember(Value = "InvalidStartJobRobotIds")]
        InvalidStartJobRobotIds,
        [EnumMember(Value = "UnregisteredCannotStartJobs")]
        UnregisteredCannotStartJobs,
        [EnumMember(Value = "LicenseExpiredCannotStartJobs")]
        LicenseExpiredCannotStartJobs,
        [EnumMember(Value = "InvalidReleaseKey")]
        InvalidReleaseKey,
        [EnumMember(Value = "InvalidPackageVersion")]
        InvalidPackageVersion,
        [EnumMember(Value = "TenantIsDisabled")]
        TenantIsDisabled,
        [EnumMember(Value = "PackageNotFound")]
        PackageNotFound,
        [EnumMember(Value = "NoRobotsAvailable")]
        NoRobotsAvailable,
        [EnumMember(Value = "PathTooLong")]
        PathTooLong,
        [EnumMember(Value = "JobExecutionFaulted")]
        JobExecutionFaulted,
        [EnumMember(Value = "InvalidJobIdOrRobotKey")]
        InvalidJobIdOrRobotKey,
        [EnumMember(Value = "InvalidJobStateForSuspend")]
        InvalidJobStateForSuspend,
        [EnumMember(Value = "JobNotFoundByPersistenceId")]
        JobNotFoundByPersistenceId,
        [EnumMember(Value = "ErrorPackagePublish")]
        ErrorPackagePublish,
        [EnumMember(Value = "ErrorSavingPackageDefinition")]
        ErrorSavingPackageDefinition,
        [EnumMember(Value = "MaxNumberJobsAlreadyExist")]
        MaxNumberJobsAlreadyExist,
        [EnumMember(Value = "HasSlaEnabedQueuesAssociated")]
        HasSlaEnabedQueuesAssociated,
        [EnumMember(Value = "VersionsManagedAutomatically")]
        VersionsManagedAutomatically,
        [EnumMember(Value = "InaccessibleFeed")]
        InaccessibleFeed,
        [EnumMember(Value = "TestAutomationJobExecutionNotSupported")]
        TestAutomationJobExecutionNotSupported,
        [EnumMember(Value = "TestAutomationProcessAlreadyExists")]
        TestAutomationProcessAlreadyExists,
        [EnumMember(Value = "CyberArkEditPasswordNotAllowed")]
        CyberArkEditPasswordNotAllowed,
        [EnumMember(Value = "LogMessageNotFound")]
        LogMessageNotFound,
        [EnumMember(Value = "LogRobotNameNotFound")]
        LogRobotNameNotFound,
        [EnumMember(Value = "EncryptionKeyNotFound")]
        EncryptionKeyNotFound,
        [EnumMember(Value = "EncryptionKeyIncorrectFormat")]
        EncryptionKeyIncorrectFormat,
        [EnumMember(Value = "AzureKeyVaultRetrieveIssue")]
        AzureKeyVaultRetrieveIssue,
        [EnumMember(Value = "AzureKeyVaultStoreIssue")]
        AzureKeyVaultStoreIssue,
        [EnumMember(Value = "TransactionReferenceRequired")]
        TransactionReferenceRequired,
        [EnumMember(Value = "InvalidTransactionProgressStatus")]
        InvalidTransactionProgressStatus,
        [EnumMember(Value = "TransactionNotStarted")]
        TransactionNotStarted,
        [EnumMember(Value = "ReviewerNotAvailable")]
        ReviewerNotAvailable,
        [EnumMember(Value = "QueueDefinitionParametersCannotChange")]
        QueueDefinitionParametersCannotChange,
        [EnumMember(Value = "QueueProcessingApplicationException")]
        QueueProcessingApplicationException,
        [EnumMember(Value = "QueueItemSchemaViolationException")]
        QueueItemSchemaViolationException,
        [EnumMember(Value = "InvalidQueueSchemaDefinition")]
        InvalidQueueSchemaDefinition,
        [EnumMember(Value = "InvalidQueueSchemaDefinitionChange")]
        InvalidQueueSchemaDefinitionChange,
        [EnumMember(Value = "InvalidQueueSchemaType")]
        InvalidQueueSchemaType,
        [EnumMember(Value = "QueueSchemaDefinitionNotFound")]
        QueueSchemaDefinitionNotFound,
        [EnumMember(Value = "SlaEnableQueueDefinitionFailure")]
        SlaEnableQueueDefinitionFailure,
        [EnumMember(Value = "QueueSlaAtPredictedRisk")]
        QueueSlaAtPredictedRisk,
        [EnumMember(Value = "QueueSlaPredictedBreach")]
        QueueSlaPredictedBreach,
        [EnumMember(Value = "QueueItemContentSizeExceeded")]
        QueueItemContentSizeExceeded,
        [EnumMember(Value = "LicenseNotFound")]
        LicenseNotFound,
        [EnumMember(Value = "LicenseExpired")]
        LicenseExpired,
        [EnumMember(Value = "LicenseAlreadyInUse")]
        LicenseAlreadyInUse,
        [EnumMember(Value = "InvalidLicenseFormat")]
        InvalidLicenseFormat,
        [EnumMember(Value = "LicenseLimitExceeded")]
        LicenseLimitExceeded,
        [EnumMember(Value = "UnattendedLicenseLimitExceeded")]
        UnattendedLicenseLimitExceeded,
        [EnumMember(Value = "NonProductionLicenseLimitExceeded")]
        NonProductionLicenseLimitExceeded,
        [EnumMember(Value = "AttendedLicenseLimitExceeded")]
        AttendedLicenseLimitExceeded,
        [EnumMember(Value = "DevelopmentLicenseLimitExceeded")]
        DevelopmentLicenseLimitExceeded,
        [EnumMember(Value = "RobotFailedToAcquireLicense")]
        RobotFailedToAcquireLicense,
        [EnumMember(Value = "NonProductionSlotsLimitExceeded")]
        NonProductionSlotsLimitExceeded,
        [EnumMember(Value = "UnattendedSlotsLimitExceeded")]
        UnattendedSlotsLimitExceeded,
        [EnumMember(Value = "LicenseUnregistered")]
        LicenseUnregistered,
        [EnumMember(Value = "LicenseNotAvailable")]
        LicenseNotAvailable,
        [EnumMember(Value = "NotEnoughAvailableSlots")]
        NotEnoughAvailableSlots,
        [EnumMember(Value = "NotEnoughRuntimeLicenses")]
        NotEnoughRuntimeLicenses,
        [EnumMember(Value = "SlotsExceedLicenseLimit")]
        SlotsExceedLicenseLimit,
        [EnumMember(Value = "NotEnoughAvailableLicenses")]
        NotEnoughAvailableLicenses,
        [EnumMember(Value = "HostLicenseLimitExceeded")]
        HostLicenseLimitExceeded,
        [EnumMember(Value = "NoHostLicense")]
        NoHostLicense,
        [EnumMember(Value = "LicenseNewInvalidArguments")]
        LicenseNewInvalidArguments,
        [EnumMember(Value = "LicenseMachineDisabled")]
        LicenseMachineDisabled,
        [EnumMember(Value = "CannotDisableBusyMachine")]
        CannotDisableBusyMachine,
        [EnumMember(Value = "HeadlessSlotsLimitExceeded")]
        HeadlessSlotsLimitExceeded,
        [EnumMember(Value = "HeadlessLicenseLimitExceeded")]
        HeadlessLicenseLimitExceeded,
        [EnumMember(Value = "TestAutomationSlotsLimitExceeded")]
        TestAutomationSlotsLimitExceeded,
        [EnumMember(Value = "TestAutomationLicenseLimitExceeded")]
        TestAutomationLicenseLimitExceeded,
        [EnumMember(Value = "ArgumentMetadataExtract")]
        ArgumentMetadataExtract,
        [EnumMember(Value = "ArgumentMetadataValidation")]
        ArgumentMetadataValidation,
        [EnumMember(Value = "ArgumentDefinitionExtract")]
        ArgumentDefinitionExtract,
        [EnumMember(Value = "ArgumentValueExtract")]
        ArgumentValueExtract,
        [EnumMember(Value = "ArgumentValidation")]
        ArgumentValidation,
        [EnumMember(Value = "PackageMetadataExtract")]
        PackageMetadataExtract,
        [EnumMember(Value = "PackageMetadataValidation")]
        PackageMetadataValidation,
        [EnumMember(Value = "ProjectTypeChangedOnUpload")]
        ProjectTypeChangedOnUpload,
        [EnumMember(Value = "EntryPointUniqueIdsAlreadyUsed")]
        EntryPointUniqueIdsAlreadyUsed,
        [EnumMember(Value = "UnknownWebhookEventType")]
        UnknownWebhookEventType,
        [EnumMember(Value = "WebhookQuotaReached")]
        WebhookQuotaReached,
        [EnumMember(Value = "ExecutionMediaStorageUnavailable")]
        ExecutionMediaStorageUnavailable,
        [EnumMember(Value = "ExecutionMediaNotAvailableForJob")]
        ExecutionMediaNotAvailableForJob,
        [EnumMember(Value = "ExecutionMediaContentNotAvailable")]
        ExecutionMediaContentNotAvailable,
        [EnumMember(Value = "CannotDeleteDefaultCredentialStore")]
        CannotDeleteDefaultCredentialStore,
        [EnumMember(Value = "CredentialStoreNotFound")]
        CredentialStoreNotFound,
        [EnumMember(Value = "UnknownCredentialStoreType")]
        UnknownCredentialStoreType,
        [EnumMember(Value = "InvalidCredentialStoreConfiguration")]
        InvalidCredentialStoreConfiguration,
        [EnumMember(Value = "FailedToReadFromCredentialStore")]
        FailedToReadFromCredentialStore,
        [EnumMember(Value = "FailedToWriteToCredentialStore")]
        FailedToWriteToCredentialStore,
        [EnumMember(Value = "CannotDeleteNonEmptyCredentialStore")]
        CannotDeleteNonEmptyCredentialStore,
        [EnumMember(Value = "ContentLengthTooLarge")]
        ContentLengthTooLarge,
        [EnumMember(Value = "TaskAssignmentError")]
        TaskAssignmentError,
        [EnumMember(Value = "TaskCompletionError")]
        TaskCompletionError,
        [EnumMember(Value = "TaskAssigneeMismatchError")]
        TaskAssigneeMismatchError,
        [EnumMember(Value = "TaskFormInvalidFormLayout")]
        TaskFormInvalidFormLayout,
        [EnumMember(Value = "TaskFormInvalidFormPayload")]
        TaskFormInvalidFormPayload,
        [EnumMember(Value = "TaskFormMultipleActions")]
        TaskFormMultipleActions,
        [EnumMember(Value = "TaskFormNoAction")]
        TaskFormNoAction,
        [EnumMember(Value = "TaskFormInvalidAction")]
        TaskFormInvalidAction,
        [EnumMember(Value = "TasksNotAllowedInModernFolder")]
        TasksNotAllowedInModernFolder,
        [EnumMember(Value = "InvalidSecureStoreContext")]
        InvalidSecureStoreContext,
        [EnumMember(Value = "MailSmtpSettingsError")]
        MailSmtpSettingsError,
        [EnumMember(Value = "CannotDeleteCalendarWhenUsedBySchedule")]
        CannotDeleteCalendarWhenUsedBySchedule,
        [EnumMember(Value = "MandatoryPropertiesForRootFolderNotSpecified")]
        MandatoryPropertiesForRootFolderNotSpecified,
        [EnumMember(Value = "IncompatibleFolderProperties")]
        IncompatibleFolderProperties,
        [EnumMember(Value = "NoHierarchyAllowedForClassicFolders")]
        NoHierarchyAllowedForClassicFolders,
        [EnumMember(Value = "MaximumFolderHierarchyDepthReached")]
        MaximumFolderHierarchyDepthReached,
        [EnumMember(Value = "CannotChangeRobotProvisionType")]
        CannotChangeRobotProvisionType,
        [EnumMember(Value = "CannotChangeFolderPermissionModel")]
        CannotChangeFolderPermissionModel,
        [EnumMember(Value = "CannotEditFolderParent")]
        CannotEditFolderParent,
        [EnumMember(Value = "EntitiesRequiredForAssignmentNotFound")]
        EntitiesRequiredForAssignmentNotFound,
        [EnumMember(Value = "CannotAssignRolesToNonFineGrainedFolders")]
        CannotAssignRolesToNonFineGrainedFolders,
        [EnumMember(Value = "InvalidFolderDisplayName")]
        InvalidFolderDisplayName,
        [EnumMember(Value = "AssociationAlreadyExists")]
        AssociationAlreadyExists,
        [EnumMember(Value = "UserDoesNotHaveAccessToFolder")]
        UserDoesNotHaveAccessToFolder,
        [EnumMember(Value = "CannotChangeRobotUserFolderAssignments")]
        CannotChangeRobotUserFolderAssignments,
        [EnumMember(Value = "CannotAssignMachineToClassicFolder")]
        CannotAssignMachineToClassicFolder,
        [EnumMember(Value = "StrategyNotAvailableInModernFolder")]
        StrategyNotAvailableInModernFolder,
        [EnumMember(Value = "StrategyNotAvailableInClassicFolder")]
        StrategyNotAvailableInClassicFolder,
        [EnumMember(Value = "ValidModernFolderIdRequired")]
        ValidModernFolderIdRequired,
        [EnumMember(Value = "NoMachineAssociatedWithFolder")]
        NoMachineAssociatedWithFolder,
        [EnumMember(Value = "MaintenanceActive")]
        MaintenanceActive,
        [EnumMember(Value = "TenantMaintenanceActive")]
        TenantMaintenanceActive,
        [EnumMember(Value = "TenantMaintenanceNotActive")]
        TenantMaintenanceNotActive,
        [EnumMember(Value = "AnalyticsNotAuthorized")]
        AnalyticsNotAuthorized,
        [EnumMember(Value = "AnalyticsTenantNotProvisioned")]
        AnalyticsTenantNotProvisioned,
        [EnumMember(Value = "AnalyticsUserIsHostUser")]
        AnalyticsUserIsHostUser,
        [EnumMember(Value = "AnalyticsUserHasNoEmail")]
        AnalyticsUserHasNoEmail,
        [EnumMember(Value = "AnalyticsUserNotFound")]
        AnalyticsUserNotFound,
        [EnumMember(Value = "AnalyticsAdminEmailProhibited")]
        AnalyticsAdminEmailProhibited,
        [EnumMember(Value = "InvalidStorageProvider")]
        InvalidStorageProvider,
        [EnumMember(Value = "BucketIsReadOnly")]
        BucketIsReadOnly,
        [EnumMember(Value = "InvalidBlobFilePath")]
        InvalidBlobFilePath,
        [EnumMember(Value = "UnavailableStorageProvider")]
        UnavailableStorageProvider,
        [EnumMember(Value = "TestSetNotNewOnCreate")]
        TestSetNotNewOnCreate,
        [EnumMember(Value = "TestAutomationKeyMismatch")]
        TestAutomationKeyMismatch,
        [EnumMember(Value = "TestSetNewOnUpdate")]
        TestSetNewOnUpdate,
        [EnumMember(Value = "TestSetEmpty")]
        TestSetEmpty,
        [EnumMember(Value = "TestSetDuplicatePackages")]
        TestSetDuplicatePackages,
        [EnumMember(Value = "TestSetVersionMaskInvalid")]
        TestSetVersionMaskInvalid,
        [EnumMember(Value = "TestSetDefinitionNotFound")]
        TestSetDefinitionNotFound,
        [EnumMember(Value = "TestSetTestCaseInvalid")]
        TestSetTestCaseInvalid,
        [EnumMember(Value = "TestSetTestCaseVersionInvalid")]
        TestSetTestCaseVersionInvalid,
        [EnumMember(Value = "TestAutomationVersionInvalid")]
        TestAutomationVersionInvalid,
        [EnumMember(Value = "TestSetExecutionEmptyTestSet")]
        TestSetExecutionEmptyTestSet,
        [EnumMember(Value = "TestSetExecutionCreateFailed")]
        TestSetExecutionCreateFailed,
        [EnumMember(Value = "TestSetExecutionDuplicateUniqueIds")]
        TestSetExecutionDuplicateUniqueIds,
        [EnumMember(Value = "TestCaseAssertionScreenshotMimeTypeMissing")]
        TestCaseAssertionScreenshotMimeTypeMissing,
        [EnumMember(Value = "TestCaseAssertionScreenshotMissing")]
        TestCaseAssertionScreenshotMissing,
        [EnumMember(Value = "InvalidTenantMoveStatus")]
        InvalidTenantMoveStatus,
        [EnumMember(Value = "TenantMoveIdConflict")]
        TenantMoveIdConflict,
        [EnumMember(Value = "TenantMoveMigrationConflict")]
        TenantMoveMigrationConflict,
        [EnumMember(Value = "MediaFileNotFound")]
        MediaFileNotFound,
        [EnumMember(Value = "MediaFileNotFoundForKey")]
        MediaFileNotFoundForKey,
        [EnumMember(Value = "InvalidMediaFilesUpload")]
        InvalidMediaFilesUpload,
        [EnumMember(Value = "MediaFileTypeNotSupported")]
        MediaFileTypeNotSupported
    }
    internal static class FailedQueueItemDtoErrorCodeEnumExtension
    {
        internal static string ToSerializedValue(this FailedQueueItemDtoErrorCode? value)
        {
            return value == null ? null : ((FailedQueueItemDtoErrorCode)value).ToSerializedValue();
        }

        internal static string ToSerializedValue(this FailedQueueItemDtoErrorCode value)
        {
            switch( value )
            {
                case FailedQueueItemDtoErrorCode.Unknown:
                    return "Unknown";
                case FailedQueueItemDtoErrorCode.MultipleErrors:
                    return "MultipleErrors";
                case FailedQueueItemDtoErrorCode.InvalidRequest:
                    return "InvalidRequest";
                case FailedQueueItemDtoErrorCode.NameAlreadyUsed:
                    return "NameAlreadyUsed";
                case FailedQueueItemDtoErrorCode.ItemNotFound:
                    return "ItemNotFound";
                case FailedQueueItemDtoErrorCode.StringProtectFailed:
                    return "StringProtectFailed";
                case FailedQueueItemDtoErrorCode.ItemAlreadyExists:
                    return "ItemAlreadyExists";
                case FailedQueueItemDtoErrorCode.ErrorDeleting:
                    return "ErrorDeleting";
                case FailedQueueItemDtoErrorCode.ErrorInserting:
                    return "ErrorInserting";
                case FailedQueueItemDtoErrorCode.ErrorUpdating:
                    return "ErrorUpdating";
                case FailedQueueItemDtoErrorCode.ErrorSendingEmail:
                    return "ErrorSendingEmail";
                case FailedQueueItemDtoErrorCode.InvalidArgument:
                    return "InvalidArgument";
                case FailedQueueItemDtoErrorCode.SqlAcquireLockFailure:
                    return "SqlAcquireLockFailure";
                case FailedQueueItemDtoErrorCode.LibrariesFeedInUse:
                    return "LibrariesFeedInUse";
                case FailedQueueItemDtoErrorCode.HasDependentItems:
                    return "HasDependentItems";
                case FailedQueueItemDtoErrorCode.ItemIsInUse:
                    return "ItemIsInUse";
                case FailedQueueItemDtoErrorCode.ParameterMissing:
                    return "ParameterMissing";
                case FailedQueueItemDtoErrorCode.ParameterInvalid:
                    return "ParameterInvalid";
                case FailedQueueItemDtoErrorCode.DuplicateReference:
                    return "DuplicateReference";
                case FailedQueueItemDtoErrorCode.ForbiddenOperation:
                    return "ForbiddenOperation";
                case FailedQueueItemDtoErrorCode.InvalidUser:
                    return "InvalidUser";
                case FailedQueueItemDtoErrorCode.FeatureDisabled:
                    return "FeatureDisabled";
                case FailedQueueItemDtoErrorCode.OptimisticConcurrency:
                    return "OptimisticConcurrency";
                case FailedQueueItemDtoErrorCode.EncryptionException:
                    return "EncryptionException";
                case FailedQueueItemDtoErrorCode.CannotCreateOrMigrateTenantDb:
                    return "CannotCreateOrMigrateTenantDb";
                case FailedQueueItemDtoErrorCode.TenantIsRequired:
                    return "TenantIsRequired";
                case FailedQueueItemDtoErrorCode.FieldNotEditable:
                    return "FieldNotEditable";
                case FailedQueueItemDtoErrorCode.ServiceUnavailable:
                    return "ServiceUnavailable";
                case FailedQueueItemDtoErrorCode.SharedAccessSignatureFailure:
                    return "SharedAccessSignatureFailure";
                case FailedQueueItemDtoErrorCode.ProviderNotSupported:
                    return "ProviderNotSupported";
                case FailedQueueItemDtoErrorCode.InvalidAuditRelationship:
                    return "InvalidAuditRelationship";
                case FailedQueueItemDtoErrorCode.InvalidOrganizationUnit:
                    return "InvalidOrganizationUnit";
                case FailedQueueItemDtoErrorCode.RequiredOrganizationUnit:
                    return "RequiredOrganizationUnit";
                case FailedQueueItemDtoErrorCode.OrganizationUnitNotEditable:
                    return "OrganizationUnitNotEditable";
                case FailedQueueItemDtoErrorCode.MachineAlreadyPairedWithDifferentLicenseKey:
                    return "MachineAlreadyPairedWithDifferentLicenseKey";
                case FailedQueueItemDtoErrorCode.NoAvailableLicenses:
                    return "NoAvailableLicenses";
                case FailedQueueItemDtoErrorCode.HasAttachedRobots:
                    return "HasAttachedRobots";
                case FailedQueueItemDtoErrorCode.InvalidMachineKey:
                    return "InvalidMachineKey";
                case FailedQueueItemDtoErrorCode.MachineNameRequired:
                    return "MachineNameRequired";
                case FailedQueueItemDtoErrorCode.UserNameRequired:
                    return "UserNameRequired";
                case FailedQueueItemDtoErrorCode.CannotDeleteBusyRobot:
                    return "CannotDeleteBusyRobot";
                case FailedQueueItemDtoErrorCode.MachineNameCannotChange:
                    return "MachineNameCannotChange";
                case FailedQueueItemDtoErrorCode.MachineLicenseCannotChange:
                    return "MachineLicenseCannotChange";
                case FailedQueueItemDtoErrorCode.CannotUpdateBusyRobot:
                    return "CannotUpdateBusyRobot";
                case FailedQueueItemDtoErrorCode.MachineTypeCannotChange:
                    return "MachineTypeCannotChange";
                case FailedQueueItemDtoErrorCode.UserNameInvalid:
                    return "UserNameInvalid";
                case FailedQueueItemDtoErrorCode.SessionAlreadyActive:
                    return "SessionAlreadyActive";
                case FailedQueueItemDtoErrorCode.CannotAssignMachineToFloatingRobot:
                    return "CannotAssignMachineToFloatingRobot";
                case FailedQueueItemDtoErrorCode.CannotUpdateRobotHostingType:
                    return "CannotUpdateRobotHostingType";
                case FailedQueueItemDtoErrorCode.CannotAssignMachineTemplateToStandardRobot:
                    return "CannotAssignMachineTemplateToStandardRobot";
                case FailedQueueItemDtoErrorCode.CannotUpdateActiveSession:
                    return "CannotUpdateActiveSession";
                case FailedQueueItemDtoErrorCode.MachineTemplateUniqueLicenseKey:
                    return "MachineTemplateUniqueLicenseKey";
                case FailedQueueItemDtoErrorCode.InvalidMachineId:
                    return "InvalidMachineId";
                case FailedQueueItemDtoErrorCode.InvalidNonProductionMachineSlots:
                    return "InvalidNonProductionMachineSlots";
                case FailedQueueItemDtoErrorCode.InvalidUnattendedMachineSlots:
                    return "InvalidUnattendedMachineSlots";
                case FailedQueueItemDtoErrorCode.DisconnectedRobot:
                    return "DisconnectedRobot";
                case FailedQueueItemDtoErrorCode.UnresponsiveRobot:
                    return "UnresponsiveRobot";
                case FailedQueueItemDtoErrorCode.UnsupportedFloatingSessionRobotType:
                    return "UnsupportedFloatingSessionRobotType";
                case FailedQueueItemDtoErrorCode.UnsupportedStandardSessionRobotType:
                    return "UnsupportedStandardSessionRobotType";
                case FailedQueueItemDtoErrorCode.EnvironmentDeploymentConflict:
                    return "EnvironmentDeploymentConflict";
                case FailedQueueItemDtoErrorCode.ServerConflict:
                    return "ServerConflict";
                case FailedQueueItemDtoErrorCode.ActionAlreadyPerformed:
                    return "ActionAlreadyPerformed";
                case FailedQueueItemDtoErrorCode.UnavailableResources:
                    return "UnavailableResources";
                case FailedQueueItemDtoErrorCode.UserIsDeleted:
                    return "UserIsDeleted";
                case FailedQueueItemDtoErrorCode.UserIsLockedOut:
                    return "UserIsLockedOut";
                case FailedQueueItemDtoErrorCode.ChangePassword:
                    return "ChangePassword";
                case FailedQueueItemDtoErrorCode.PasswordExpired:
                    return "PasswordExpired";
                case FailedQueueItemDtoErrorCode.InvalidPassword:
                    return "InvalidPassword";
                case FailedQueueItemDtoErrorCode.CannotDeleteStaticRole:
                    return "CannotDeleteStaticRole";
                case FailedQueueItemDtoErrorCode.UserNotEditable:
                    return "UserNotEditable";
                case FailedQueueItemDtoErrorCode.DomainUnreachable:
                    return "DomainUnreachable";
                case FailedQueueItemDtoErrorCode.PasswordResetFailed:
                    return "PasswordResetFailed";
                case FailedQueueItemDtoErrorCode.ConfirmEmailFailed:
                    return "ConfirmEmailFailed";
                case FailedQueueItemDtoErrorCode.CannotUsePreviousPassword:
                    return "CannotUsePreviousPassword";
                case FailedQueueItemDtoErrorCode.RoleIsNotEditable:
                    return "RoleIsNotEditable";
                case FailedQueueItemDtoErrorCode.UserNotFoundInDomain:
                    return "UserNotFoundInDomain";
                case FailedQueueItemDtoErrorCode.CannotUpdateUsername:
                    return "CannotUpdateUsername";
                case FailedQueueItemDtoErrorCode.InvalidLoginMethod:
                    return "InvalidLoginMethod";
                case FailedQueueItemDtoErrorCode.InvalidUsernameOrPassword:
                    return "InvalidUsernameOrPassword";
                case FailedQueueItemDtoErrorCode.MultipleMatchingUsers:
                    return "MultipleMatchingUsers";
                case FailedQueueItemDtoErrorCode.CannotCallFromHost:
                    return "CannotCallFromHost";
                case FailedQueueItemDtoErrorCode.CreateNotAllowed:
                    return "CreateNotAllowed";
                case FailedQueueItemDtoErrorCode.ProvisionError:
                    return "ProvisionError";
                case FailedQueueItemDtoErrorCode.EmptyDomainOrUsername:
                    return "EmptyDomainOrUsername";
                case FailedQueueItemDtoErrorCode.NotDirectoryUserOrGroup:
                    return "NotDirectoryUserOrGroup";
                case FailedQueueItemDtoErrorCode.CredentialAssetEmptyPasswordForNewUser:
                    return "CredentialAssetEmptyPasswordForNewUser";
                case FailedQueueItemDtoErrorCode.CredentialAssetEmptyForNewRobot:
                    return "CredentialAssetEmptyForNewRobot";
                case FailedQueueItemDtoErrorCode.AssetTypeNonUpdatable:
                    return "AssetTypeNonUpdatable";
                case FailedQueueItemDtoErrorCode.AssetNotAvailableForRobot:
                    return "AssetNotAvailableForRobot";
                case FailedQueueItemDtoErrorCode.InvalidCron:
                    return "InvalidCron";
                case FailedQueueItemDtoErrorCode.ScheduleWillNeverRun:
                    return "ScheduleWillNeverRun";
                case FailedQueueItemDtoErrorCode.ScheduleMisfired:
                    return "ScheduleMisfired";
                case FailedQueueItemDtoErrorCode.ScheduleInvalidTimeZone:
                    return "ScheduleInvalidTimeZone";
                case FailedQueueItemDtoErrorCode.InvalidScheduleKey:
                    return "InvalidScheduleKey";
                case FailedQueueItemDtoErrorCode.ScheduleIsNotEnabled:
                    return "ScheduleIsNotEnabled";
                case FailedQueueItemDtoErrorCode.ScheduleNotAssociatedWithAQueue:
                    return "ScheduleNotAssociatedWithAQueue";
                case FailedQueueItemDtoErrorCode.ScheduleCannotBeAssociatedWithAQueue:
                    return "ScheduleCannotBeAssociatedWithAQueue";
                case FailedQueueItemDtoErrorCode.UserIsAssignedToTriggers:
                    return "UserIsAssignedToTriggers";
                case FailedQueueItemDtoErrorCode.DownloadUnavailable:
                    return "DownloadUnavailable";
                case FailedQueueItemDtoErrorCode.CannotConnectToPackagesRepository:
                    return "CannotConnectToPackagesRepository";
                case FailedQueueItemDtoErrorCode.NotSupportedByExternalFeeds:
                    return "NotSupportedByExternalFeeds";
                case FailedQueueItemDtoErrorCode.ErrorDownloading:
                    return "ErrorDownloading";
                case FailedQueueItemDtoErrorCode.InvalidPackageDetails:
                    return "InvalidPackageDetails";
                case FailedQueueItemDtoErrorCode.TenantFeedInUse:
                    return "TenantFeedInUse";
                case FailedQueueItemDtoErrorCode.InvalidProcessKey:
                    return "InvalidProcessKey";
                case FailedQueueItemDtoErrorCode.JobTypeCannotBeStopped:
                    return "JobTypeCannotBeStopped";
                case FailedQueueItemDtoErrorCode.JobCannotBeCancelled:
                    return "JobCannotBeCancelled";
                case FailedQueueItemDtoErrorCode.JobCannotBeTerminated:
                    return "JobCannotBeTerminated";
                case FailedQueueItemDtoErrorCode.VersionNotFound:
                    return "VersionNotFound";
                case FailedQueueItemDtoErrorCode.ProcessNotFound:
                    return "ProcessNotFound";
                case FailedQueueItemDtoErrorCode.HasAttachedProcesses:
                    return "HasAttachedProcesses";
                case FailedQueueItemDtoErrorCode.InvalidExtension:
                    return "InvalidExtension";
                case FailedQueueItemDtoErrorCode.InvalidPackageCount:
                    return "InvalidPackageCount";
                case FailedQueueItemDtoErrorCode.PreviousVersionNotFound:
                    return "PreviousVersionNotFound";
                case FailedQueueItemDtoErrorCode.HasRunningJobs:
                    return "HasRunningJobs";
                case FailedQueueItemDtoErrorCode.TenantNotFound:
                    return "TenantNotFound";
                case FailedQueueItemDtoErrorCode.PendingJobsAlreadyExist:
                    return "PendingJobsAlreadyExist";
                case FailedQueueItemDtoErrorCode.InvalidStartJobRobotIds:
                    return "InvalidStartJobRobotIds";
                case FailedQueueItemDtoErrorCode.UnregisteredCannotStartJobs:
                    return "UnregisteredCannotStartJobs";
                case FailedQueueItemDtoErrorCode.LicenseExpiredCannotStartJobs:
                    return "LicenseExpiredCannotStartJobs";
                case FailedQueueItemDtoErrorCode.InvalidReleaseKey:
                    return "InvalidReleaseKey";
                case FailedQueueItemDtoErrorCode.InvalidPackageVersion:
                    return "InvalidPackageVersion";
                case FailedQueueItemDtoErrorCode.TenantIsDisabled:
                    return "TenantIsDisabled";
                case FailedQueueItemDtoErrorCode.PackageNotFound:
                    return "PackageNotFound";
                case FailedQueueItemDtoErrorCode.NoRobotsAvailable:
                    return "NoRobotsAvailable";
                case FailedQueueItemDtoErrorCode.PathTooLong:
                    return "PathTooLong";
                case FailedQueueItemDtoErrorCode.JobExecutionFaulted:
                    return "JobExecutionFaulted";
                case FailedQueueItemDtoErrorCode.InvalidJobIdOrRobotKey:
                    return "InvalidJobIdOrRobotKey";
                case FailedQueueItemDtoErrorCode.InvalidJobStateForSuspend:
                    return "InvalidJobStateForSuspend";
                case FailedQueueItemDtoErrorCode.JobNotFoundByPersistenceId:
                    return "JobNotFoundByPersistenceId";
                case FailedQueueItemDtoErrorCode.ErrorPackagePublish:
                    return "ErrorPackagePublish";
                case FailedQueueItemDtoErrorCode.ErrorSavingPackageDefinition:
                    return "ErrorSavingPackageDefinition";
                case FailedQueueItemDtoErrorCode.MaxNumberJobsAlreadyExist:
                    return "MaxNumberJobsAlreadyExist";
                case FailedQueueItemDtoErrorCode.HasSlaEnabedQueuesAssociated:
                    return "HasSlaEnabedQueuesAssociated";
                case FailedQueueItemDtoErrorCode.VersionsManagedAutomatically:
                    return "VersionsManagedAutomatically";
                case FailedQueueItemDtoErrorCode.InaccessibleFeed:
                    return "InaccessibleFeed";
                case FailedQueueItemDtoErrorCode.TestAutomationJobExecutionNotSupported:
                    return "TestAutomationJobExecutionNotSupported";
                case FailedQueueItemDtoErrorCode.TestAutomationProcessAlreadyExists:
                    return "TestAutomationProcessAlreadyExists";
                case FailedQueueItemDtoErrorCode.CyberArkEditPasswordNotAllowed:
                    return "CyberArkEditPasswordNotAllowed";
                case FailedQueueItemDtoErrorCode.LogMessageNotFound:
                    return "LogMessageNotFound";
                case FailedQueueItemDtoErrorCode.LogRobotNameNotFound:
                    return "LogRobotNameNotFound";
                case FailedQueueItemDtoErrorCode.EncryptionKeyNotFound:
                    return "EncryptionKeyNotFound";
                case FailedQueueItemDtoErrorCode.EncryptionKeyIncorrectFormat:
                    return "EncryptionKeyIncorrectFormat";
                case FailedQueueItemDtoErrorCode.AzureKeyVaultRetrieveIssue:
                    return "AzureKeyVaultRetrieveIssue";
                case FailedQueueItemDtoErrorCode.AzureKeyVaultStoreIssue:
                    return "AzureKeyVaultStoreIssue";
                case FailedQueueItemDtoErrorCode.TransactionReferenceRequired:
                    return "TransactionReferenceRequired";
                case FailedQueueItemDtoErrorCode.InvalidTransactionProgressStatus:
                    return "InvalidTransactionProgressStatus";
                case FailedQueueItemDtoErrorCode.TransactionNotStarted:
                    return "TransactionNotStarted";
                case FailedQueueItemDtoErrorCode.ReviewerNotAvailable:
                    return "ReviewerNotAvailable";
                case FailedQueueItemDtoErrorCode.QueueDefinitionParametersCannotChange:
                    return "QueueDefinitionParametersCannotChange";
                case FailedQueueItemDtoErrorCode.QueueProcessingApplicationException:
                    return "QueueProcessingApplicationException";
                case FailedQueueItemDtoErrorCode.QueueItemSchemaViolationException:
                    return "QueueItemSchemaViolationException";
                case FailedQueueItemDtoErrorCode.InvalidQueueSchemaDefinition:
                    return "InvalidQueueSchemaDefinition";
                case FailedQueueItemDtoErrorCode.InvalidQueueSchemaDefinitionChange:
                    return "InvalidQueueSchemaDefinitionChange";
                case FailedQueueItemDtoErrorCode.InvalidQueueSchemaType:
                    return "InvalidQueueSchemaType";
                case FailedQueueItemDtoErrorCode.QueueSchemaDefinitionNotFound:
                    return "QueueSchemaDefinitionNotFound";
                case FailedQueueItemDtoErrorCode.SlaEnableQueueDefinitionFailure:
                    return "SlaEnableQueueDefinitionFailure";
                case FailedQueueItemDtoErrorCode.QueueSlaAtPredictedRisk:
                    return "QueueSlaAtPredictedRisk";
                case FailedQueueItemDtoErrorCode.QueueSlaPredictedBreach:
                    return "QueueSlaPredictedBreach";
                case FailedQueueItemDtoErrorCode.QueueItemContentSizeExceeded:
                    return "QueueItemContentSizeExceeded";
                case FailedQueueItemDtoErrorCode.LicenseNotFound:
                    return "LicenseNotFound";
                case FailedQueueItemDtoErrorCode.LicenseExpired:
                    return "LicenseExpired";
                case FailedQueueItemDtoErrorCode.LicenseAlreadyInUse:
                    return "LicenseAlreadyInUse";
                case FailedQueueItemDtoErrorCode.InvalidLicenseFormat:
                    return "InvalidLicenseFormat";
                case FailedQueueItemDtoErrorCode.LicenseLimitExceeded:
                    return "LicenseLimitExceeded";
                case FailedQueueItemDtoErrorCode.UnattendedLicenseLimitExceeded:
                    return "UnattendedLicenseLimitExceeded";
                case FailedQueueItemDtoErrorCode.NonProductionLicenseLimitExceeded:
                    return "NonProductionLicenseLimitExceeded";
                case FailedQueueItemDtoErrorCode.AttendedLicenseLimitExceeded:
                    return "AttendedLicenseLimitExceeded";
                case FailedQueueItemDtoErrorCode.DevelopmentLicenseLimitExceeded:
                    return "DevelopmentLicenseLimitExceeded";
                case FailedQueueItemDtoErrorCode.RobotFailedToAcquireLicense:
                    return "RobotFailedToAcquireLicense";
                case FailedQueueItemDtoErrorCode.NonProductionSlotsLimitExceeded:
                    return "NonProductionSlotsLimitExceeded";
                case FailedQueueItemDtoErrorCode.UnattendedSlotsLimitExceeded:
                    return "UnattendedSlotsLimitExceeded";
                case FailedQueueItemDtoErrorCode.LicenseUnregistered:
                    return "LicenseUnregistered";
                case FailedQueueItemDtoErrorCode.LicenseNotAvailable:
                    return "LicenseNotAvailable";
                case FailedQueueItemDtoErrorCode.NotEnoughAvailableSlots:
                    return "NotEnoughAvailableSlots";
                case FailedQueueItemDtoErrorCode.NotEnoughRuntimeLicenses:
                    return "NotEnoughRuntimeLicenses";
                case FailedQueueItemDtoErrorCode.SlotsExceedLicenseLimit:
                    return "SlotsExceedLicenseLimit";
                case FailedQueueItemDtoErrorCode.NotEnoughAvailableLicenses:
                    return "NotEnoughAvailableLicenses";
                case FailedQueueItemDtoErrorCode.HostLicenseLimitExceeded:
                    return "HostLicenseLimitExceeded";
                case FailedQueueItemDtoErrorCode.NoHostLicense:
                    return "NoHostLicense";
                case FailedQueueItemDtoErrorCode.LicenseNewInvalidArguments:
                    return "LicenseNewInvalidArguments";
                case FailedQueueItemDtoErrorCode.LicenseMachineDisabled:
                    return "LicenseMachineDisabled";
                case FailedQueueItemDtoErrorCode.CannotDisableBusyMachine:
                    return "CannotDisableBusyMachine";
                case FailedQueueItemDtoErrorCode.HeadlessSlotsLimitExceeded:
                    return "HeadlessSlotsLimitExceeded";
                case FailedQueueItemDtoErrorCode.HeadlessLicenseLimitExceeded:
                    return "HeadlessLicenseLimitExceeded";
                case FailedQueueItemDtoErrorCode.TestAutomationSlotsLimitExceeded:
                    return "TestAutomationSlotsLimitExceeded";
                case FailedQueueItemDtoErrorCode.TestAutomationLicenseLimitExceeded:
                    return "TestAutomationLicenseLimitExceeded";
                case FailedQueueItemDtoErrorCode.ArgumentMetadataExtract:
                    return "ArgumentMetadataExtract";
                case FailedQueueItemDtoErrorCode.ArgumentMetadataValidation:
                    return "ArgumentMetadataValidation";
                case FailedQueueItemDtoErrorCode.ArgumentDefinitionExtract:
                    return "ArgumentDefinitionExtract";
                case FailedQueueItemDtoErrorCode.ArgumentValueExtract:
                    return "ArgumentValueExtract";
                case FailedQueueItemDtoErrorCode.ArgumentValidation:
                    return "ArgumentValidation";
                case FailedQueueItemDtoErrorCode.PackageMetadataExtract:
                    return "PackageMetadataExtract";
                case FailedQueueItemDtoErrorCode.PackageMetadataValidation:
                    return "PackageMetadataValidation";
                case FailedQueueItemDtoErrorCode.ProjectTypeChangedOnUpload:
                    return "ProjectTypeChangedOnUpload";
                case FailedQueueItemDtoErrorCode.EntryPointUniqueIdsAlreadyUsed:
                    return "EntryPointUniqueIdsAlreadyUsed";
                case FailedQueueItemDtoErrorCode.UnknownWebhookEventType:
                    return "UnknownWebhookEventType";
                case FailedQueueItemDtoErrorCode.WebhookQuotaReached:
                    return "WebhookQuotaReached";
                case FailedQueueItemDtoErrorCode.ExecutionMediaStorageUnavailable:
                    return "ExecutionMediaStorageUnavailable";
                case FailedQueueItemDtoErrorCode.ExecutionMediaNotAvailableForJob:
                    return "ExecutionMediaNotAvailableForJob";
                case FailedQueueItemDtoErrorCode.ExecutionMediaContentNotAvailable:
                    return "ExecutionMediaContentNotAvailable";
                case FailedQueueItemDtoErrorCode.CannotDeleteDefaultCredentialStore:
                    return "CannotDeleteDefaultCredentialStore";
                case FailedQueueItemDtoErrorCode.CredentialStoreNotFound:
                    return "CredentialStoreNotFound";
                case FailedQueueItemDtoErrorCode.UnknownCredentialStoreType:
                    return "UnknownCredentialStoreType";
                case FailedQueueItemDtoErrorCode.InvalidCredentialStoreConfiguration:
                    return "InvalidCredentialStoreConfiguration";
                case FailedQueueItemDtoErrorCode.FailedToReadFromCredentialStore:
                    return "FailedToReadFromCredentialStore";
                case FailedQueueItemDtoErrorCode.FailedToWriteToCredentialStore:
                    return "FailedToWriteToCredentialStore";
                case FailedQueueItemDtoErrorCode.CannotDeleteNonEmptyCredentialStore:
                    return "CannotDeleteNonEmptyCredentialStore";
                case FailedQueueItemDtoErrorCode.ContentLengthTooLarge:
                    return "ContentLengthTooLarge";
                case FailedQueueItemDtoErrorCode.TaskAssignmentError:
                    return "TaskAssignmentError";
                case FailedQueueItemDtoErrorCode.TaskCompletionError:
                    return "TaskCompletionError";
                case FailedQueueItemDtoErrorCode.TaskAssigneeMismatchError:
                    return "TaskAssigneeMismatchError";
                case FailedQueueItemDtoErrorCode.TaskFormInvalidFormLayout:
                    return "TaskFormInvalidFormLayout";
                case FailedQueueItemDtoErrorCode.TaskFormInvalidFormPayload:
                    return "TaskFormInvalidFormPayload";
                case FailedQueueItemDtoErrorCode.TaskFormMultipleActions:
                    return "TaskFormMultipleActions";
                case FailedQueueItemDtoErrorCode.TaskFormNoAction:
                    return "TaskFormNoAction";
                case FailedQueueItemDtoErrorCode.TaskFormInvalidAction:
                    return "TaskFormInvalidAction";
                case FailedQueueItemDtoErrorCode.TasksNotAllowedInModernFolder:
                    return "TasksNotAllowedInModernFolder";
                case FailedQueueItemDtoErrorCode.InvalidSecureStoreContext:
                    return "InvalidSecureStoreContext";
                case FailedQueueItemDtoErrorCode.MailSmtpSettingsError:
                    return "MailSmtpSettingsError";
                case FailedQueueItemDtoErrorCode.CannotDeleteCalendarWhenUsedBySchedule:
                    return "CannotDeleteCalendarWhenUsedBySchedule";
                case FailedQueueItemDtoErrorCode.MandatoryPropertiesForRootFolderNotSpecified:
                    return "MandatoryPropertiesForRootFolderNotSpecified";
                case FailedQueueItemDtoErrorCode.IncompatibleFolderProperties:
                    return "IncompatibleFolderProperties";
                case FailedQueueItemDtoErrorCode.NoHierarchyAllowedForClassicFolders:
                    return "NoHierarchyAllowedForClassicFolders";
                case FailedQueueItemDtoErrorCode.MaximumFolderHierarchyDepthReached:
                    return "MaximumFolderHierarchyDepthReached";
                case FailedQueueItemDtoErrorCode.CannotChangeRobotProvisionType:
                    return "CannotChangeRobotProvisionType";
                case FailedQueueItemDtoErrorCode.CannotChangeFolderPermissionModel:
                    return "CannotChangeFolderPermissionModel";
                case FailedQueueItemDtoErrorCode.CannotEditFolderParent:
                    return "CannotEditFolderParent";
                case FailedQueueItemDtoErrorCode.EntitiesRequiredForAssignmentNotFound:
                    return "EntitiesRequiredForAssignmentNotFound";
                case FailedQueueItemDtoErrorCode.CannotAssignRolesToNonFineGrainedFolders:
                    return "CannotAssignRolesToNonFineGrainedFolders";
                case FailedQueueItemDtoErrorCode.InvalidFolderDisplayName:
                    return "InvalidFolderDisplayName";
                case FailedQueueItemDtoErrorCode.AssociationAlreadyExists:
                    return "AssociationAlreadyExists";
                case FailedQueueItemDtoErrorCode.UserDoesNotHaveAccessToFolder:
                    return "UserDoesNotHaveAccessToFolder";
                case FailedQueueItemDtoErrorCode.CannotChangeRobotUserFolderAssignments:
                    return "CannotChangeRobotUserFolderAssignments";
                case FailedQueueItemDtoErrorCode.CannotAssignMachineToClassicFolder:
                    return "CannotAssignMachineToClassicFolder";
                case FailedQueueItemDtoErrorCode.StrategyNotAvailableInModernFolder:
                    return "StrategyNotAvailableInModernFolder";
                case FailedQueueItemDtoErrorCode.StrategyNotAvailableInClassicFolder:
                    return "StrategyNotAvailableInClassicFolder";
                case FailedQueueItemDtoErrorCode.ValidModernFolderIdRequired:
                    return "ValidModernFolderIdRequired";
                case FailedQueueItemDtoErrorCode.NoMachineAssociatedWithFolder:
                    return "NoMachineAssociatedWithFolder";
                case FailedQueueItemDtoErrorCode.MaintenanceActive:
                    return "MaintenanceActive";
                case FailedQueueItemDtoErrorCode.TenantMaintenanceActive:
                    return "TenantMaintenanceActive";
                case FailedQueueItemDtoErrorCode.TenantMaintenanceNotActive:
                    return "TenantMaintenanceNotActive";
                case FailedQueueItemDtoErrorCode.AnalyticsNotAuthorized:
                    return "AnalyticsNotAuthorized";
                case FailedQueueItemDtoErrorCode.AnalyticsTenantNotProvisioned:
                    return "AnalyticsTenantNotProvisioned";
                case FailedQueueItemDtoErrorCode.AnalyticsUserIsHostUser:
                    return "AnalyticsUserIsHostUser";
                case FailedQueueItemDtoErrorCode.AnalyticsUserHasNoEmail:
                    return "AnalyticsUserHasNoEmail";
                case FailedQueueItemDtoErrorCode.AnalyticsUserNotFound:
                    return "AnalyticsUserNotFound";
                case FailedQueueItemDtoErrorCode.AnalyticsAdminEmailProhibited:
                    return "AnalyticsAdminEmailProhibited";
                case FailedQueueItemDtoErrorCode.InvalidStorageProvider:
                    return "InvalidStorageProvider";
                case FailedQueueItemDtoErrorCode.BucketIsReadOnly:
                    return "BucketIsReadOnly";
                case FailedQueueItemDtoErrorCode.InvalidBlobFilePath:
                    return "InvalidBlobFilePath";
                case FailedQueueItemDtoErrorCode.UnavailableStorageProvider:
                    return "UnavailableStorageProvider";
                case FailedQueueItemDtoErrorCode.TestSetNotNewOnCreate:
                    return "TestSetNotNewOnCreate";
                case FailedQueueItemDtoErrorCode.TestAutomationKeyMismatch:
                    return "TestAutomationKeyMismatch";
                case FailedQueueItemDtoErrorCode.TestSetNewOnUpdate:
                    return "TestSetNewOnUpdate";
                case FailedQueueItemDtoErrorCode.TestSetEmpty:
                    return "TestSetEmpty";
                case FailedQueueItemDtoErrorCode.TestSetDuplicatePackages:
                    return "TestSetDuplicatePackages";
                case FailedQueueItemDtoErrorCode.TestSetVersionMaskInvalid:
                    return "TestSetVersionMaskInvalid";
                case FailedQueueItemDtoErrorCode.TestSetDefinitionNotFound:
                    return "TestSetDefinitionNotFound";
                case FailedQueueItemDtoErrorCode.TestSetTestCaseInvalid:
                    return "TestSetTestCaseInvalid";
                case FailedQueueItemDtoErrorCode.TestSetTestCaseVersionInvalid:
                    return "TestSetTestCaseVersionInvalid";
                case FailedQueueItemDtoErrorCode.TestAutomationVersionInvalid:
                    return "TestAutomationVersionInvalid";
                case FailedQueueItemDtoErrorCode.TestSetExecutionEmptyTestSet:
                    return "TestSetExecutionEmptyTestSet";
                case FailedQueueItemDtoErrorCode.TestSetExecutionCreateFailed:
                    return "TestSetExecutionCreateFailed";
                case FailedQueueItemDtoErrorCode.TestSetExecutionDuplicateUniqueIds:
                    return "TestSetExecutionDuplicateUniqueIds";
                case FailedQueueItemDtoErrorCode.TestCaseAssertionScreenshotMimeTypeMissing:
                    return "TestCaseAssertionScreenshotMimeTypeMissing";
                case FailedQueueItemDtoErrorCode.TestCaseAssertionScreenshotMissing:
                    return "TestCaseAssertionScreenshotMissing";
                case FailedQueueItemDtoErrorCode.InvalidTenantMoveStatus:
                    return "InvalidTenantMoveStatus";
                case FailedQueueItemDtoErrorCode.TenantMoveIdConflict:
                    return "TenantMoveIdConflict";
                case FailedQueueItemDtoErrorCode.TenantMoveMigrationConflict:
                    return "TenantMoveMigrationConflict";
                case FailedQueueItemDtoErrorCode.MediaFileNotFound:
                    return "MediaFileNotFound";
                case FailedQueueItemDtoErrorCode.MediaFileNotFoundForKey:
                    return "MediaFileNotFoundForKey";
                case FailedQueueItemDtoErrorCode.InvalidMediaFilesUpload:
                    return "InvalidMediaFilesUpload";
                case FailedQueueItemDtoErrorCode.MediaFileTypeNotSupported:
                    return "MediaFileTypeNotSupported";
            }
            return null;
        }

        internal static FailedQueueItemDtoErrorCode? ParseFailedQueueItemDtoErrorCode(this string value)
        {
            switch( value )
            {
                case "Unknown":
                    return FailedQueueItemDtoErrorCode.Unknown;
                case "MultipleErrors":
                    return FailedQueueItemDtoErrorCode.MultipleErrors;
                case "InvalidRequest":
                    return FailedQueueItemDtoErrorCode.InvalidRequest;
                case "NameAlreadyUsed":
                    return FailedQueueItemDtoErrorCode.NameAlreadyUsed;
                case "ItemNotFound":
                    return FailedQueueItemDtoErrorCode.ItemNotFound;
                case "StringProtectFailed":
                    return FailedQueueItemDtoErrorCode.StringProtectFailed;
                case "ItemAlreadyExists":
                    return FailedQueueItemDtoErrorCode.ItemAlreadyExists;
                case "ErrorDeleting":
                    return FailedQueueItemDtoErrorCode.ErrorDeleting;
                case "ErrorInserting":
                    return FailedQueueItemDtoErrorCode.ErrorInserting;
                case "ErrorUpdating":
                    return FailedQueueItemDtoErrorCode.ErrorUpdating;
                case "ErrorSendingEmail":
                    return FailedQueueItemDtoErrorCode.ErrorSendingEmail;
                case "InvalidArgument":
                    return FailedQueueItemDtoErrorCode.InvalidArgument;
                case "SqlAcquireLockFailure":
                    return FailedQueueItemDtoErrorCode.SqlAcquireLockFailure;
                case "LibrariesFeedInUse":
                    return FailedQueueItemDtoErrorCode.LibrariesFeedInUse;
                case "HasDependentItems":
                    return FailedQueueItemDtoErrorCode.HasDependentItems;
                case "ItemIsInUse":
                    return FailedQueueItemDtoErrorCode.ItemIsInUse;
                case "ParameterMissing":
                    return FailedQueueItemDtoErrorCode.ParameterMissing;
                case "ParameterInvalid":
                    return FailedQueueItemDtoErrorCode.ParameterInvalid;
                case "DuplicateReference":
                    return FailedQueueItemDtoErrorCode.DuplicateReference;
                case "ForbiddenOperation":
                    return FailedQueueItemDtoErrorCode.ForbiddenOperation;
                case "InvalidUser":
                    return FailedQueueItemDtoErrorCode.InvalidUser;
                case "FeatureDisabled":
                    return FailedQueueItemDtoErrorCode.FeatureDisabled;
                case "OptimisticConcurrency":
                    return FailedQueueItemDtoErrorCode.OptimisticConcurrency;
                case "EncryptionException":
                    return FailedQueueItemDtoErrorCode.EncryptionException;
                case "CannotCreateOrMigrateTenantDb":
                    return FailedQueueItemDtoErrorCode.CannotCreateOrMigrateTenantDb;
                case "TenantIsRequired":
                    return FailedQueueItemDtoErrorCode.TenantIsRequired;
                case "FieldNotEditable":
                    return FailedQueueItemDtoErrorCode.FieldNotEditable;
                case "ServiceUnavailable":
                    return FailedQueueItemDtoErrorCode.ServiceUnavailable;
                case "SharedAccessSignatureFailure":
                    return FailedQueueItemDtoErrorCode.SharedAccessSignatureFailure;
                case "ProviderNotSupported":
                    return FailedQueueItemDtoErrorCode.ProviderNotSupported;
                case "InvalidAuditRelationship":
                    return FailedQueueItemDtoErrorCode.InvalidAuditRelationship;
                case "InvalidOrganizationUnit":
                    return FailedQueueItemDtoErrorCode.InvalidOrganizationUnit;
                case "RequiredOrganizationUnit":
                    return FailedQueueItemDtoErrorCode.RequiredOrganizationUnit;
                case "OrganizationUnitNotEditable":
                    return FailedQueueItemDtoErrorCode.OrganizationUnitNotEditable;
                case "MachineAlreadyPairedWithDifferentLicenseKey":
                    return FailedQueueItemDtoErrorCode.MachineAlreadyPairedWithDifferentLicenseKey;
                case "NoAvailableLicenses":
                    return FailedQueueItemDtoErrorCode.NoAvailableLicenses;
                case "HasAttachedRobots":
                    return FailedQueueItemDtoErrorCode.HasAttachedRobots;
                case "InvalidMachineKey":
                    return FailedQueueItemDtoErrorCode.InvalidMachineKey;
                case "MachineNameRequired":
                    return FailedQueueItemDtoErrorCode.MachineNameRequired;
                case "UserNameRequired":
                    return FailedQueueItemDtoErrorCode.UserNameRequired;
                case "CannotDeleteBusyRobot":
                    return FailedQueueItemDtoErrorCode.CannotDeleteBusyRobot;
                case "MachineNameCannotChange":
                    return FailedQueueItemDtoErrorCode.MachineNameCannotChange;
                case "MachineLicenseCannotChange":
                    return FailedQueueItemDtoErrorCode.MachineLicenseCannotChange;
                case "CannotUpdateBusyRobot":
                    return FailedQueueItemDtoErrorCode.CannotUpdateBusyRobot;
                case "MachineTypeCannotChange":
                    return FailedQueueItemDtoErrorCode.MachineTypeCannotChange;
                case "UserNameInvalid":
                    return FailedQueueItemDtoErrorCode.UserNameInvalid;
                case "SessionAlreadyActive":
                    return FailedQueueItemDtoErrorCode.SessionAlreadyActive;
                case "CannotAssignMachineToFloatingRobot":
                    return FailedQueueItemDtoErrorCode.CannotAssignMachineToFloatingRobot;
                case "CannotUpdateRobotHostingType":
                    return FailedQueueItemDtoErrorCode.CannotUpdateRobotHostingType;
                case "CannotAssignMachineTemplateToStandardRobot":
                    return FailedQueueItemDtoErrorCode.CannotAssignMachineTemplateToStandardRobot;
                case "CannotUpdateActiveSession":
                    return FailedQueueItemDtoErrorCode.CannotUpdateActiveSession;
                case "MachineTemplateUniqueLicenseKey":
                    return FailedQueueItemDtoErrorCode.MachineTemplateUniqueLicenseKey;
                case "InvalidMachineId":
                    return FailedQueueItemDtoErrorCode.InvalidMachineId;
                case "InvalidNonProductionMachineSlots":
                    return FailedQueueItemDtoErrorCode.InvalidNonProductionMachineSlots;
                case "InvalidUnattendedMachineSlots":
                    return FailedQueueItemDtoErrorCode.InvalidUnattendedMachineSlots;
                case "DisconnectedRobot":
                    return FailedQueueItemDtoErrorCode.DisconnectedRobot;
                case "UnresponsiveRobot":
                    return FailedQueueItemDtoErrorCode.UnresponsiveRobot;
                case "UnsupportedFloatingSessionRobotType":
                    return FailedQueueItemDtoErrorCode.UnsupportedFloatingSessionRobotType;
                case "UnsupportedStandardSessionRobotType":
                    return FailedQueueItemDtoErrorCode.UnsupportedStandardSessionRobotType;
                case "EnvironmentDeploymentConflict":
                    return FailedQueueItemDtoErrorCode.EnvironmentDeploymentConflict;
                case "ServerConflict":
                    return FailedQueueItemDtoErrorCode.ServerConflict;
                case "ActionAlreadyPerformed":
                    return FailedQueueItemDtoErrorCode.ActionAlreadyPerformed;
                case "UnavailableResources":
                    return FailedQueueItemDtoErrorCode.UnavailableResources;
                case "UserIsDeleted":
                    return FailedQueueItemDtoErrorCode.UserIsDeleted;
                case "UserIsLockedOut":
                    return FailedQueueItemDtoErrorCode.UserIsLockedOut;
                case "ChangePassword":
                    return FailedQueueItemDtoErrorCode.ChangePassword;
                case "PasswordExpired":
                    return FailedQueueItemDtoErrorCode.PasswordExpired;
                case "InvalidPassword":
                    return FailedQueueItemDtoErrorCode.InvalidPassword;
                case "CannotDeleteStaticRole":
                    return FailedQueueItemDtoErrorCode.CannotDeleteStaticRole;
                case "UserNotEditable":
                    return FailedQueueItemDtoErrorCode.UserNotEditable;
                case "DomainUnreachable":
                    return FailedQueueItemDtoErrorCode.DomainUnreachable;
                case "PasswordResetFailed":
                    return FailedQueueItemDtoErrorCode.PasswordResetFailed;
                case "ConfirmEmailFailed":
                    return FailedQueueItemDtoErrorCode.ConfirmEmailFailed;
                case "CannotUsePreviousPassword":
                    return FailedQueueItemDtoErrorCode.CannotUsePreviousPassword;
                case "RoleIsNotEditable":
                    return FailedQueueItemDtoErrorCode.RoleIsNotEditable;
                case "UserNotFoundInDomain":
                    return FailedQueueItemDtoErrorCode.UserNotFoundInDomain;
                case "CannotUpdateUsername":
                    return FailedQueueItemDtoErrorCode.CannotUpdateUsername;
                case "InvalidLoginMethod":
                    return FailedQueueItemDtoErrorCode.InvalidLoginMethod;
                case "InvalidUsernameOrPassword":
                    return FailedQueueItemDtoErrorCode.InvalidUsernameOrPassword;
                case "MultipleMatchingUsers":
                    return FailedQueueItemDtoErrorCode.MultipleMatchingUsers;
                case "CannotCallFromHost":
                    return FailedQueueItemDtoErrorCode.CannotCallFromHost;
                case "CreateNotAllowed":
                    return FailedQueueItemDtoErrorCode.CreateNotAllowed;
                case "ProvisionError":
                    return FailedQueueItemDtoErrorCode.ProvisionError;
                case "EmptyDomainOrUsername":
                    return FailedQueueItemDtoErrorCode.EmptyDomainOrUsername;
                case "NotDirectoryUserOrGroup":
                    return FailedQueueItemDtoErrorCode.NotDirectoryUserOrGroup;
                case "CredentialAssetEmptyPasswordForNewUser":
                    return FailedQueueItemDtoErrorCode.CredentialAssetEmptyPasswordForNewUser;
                case "CredentialAssetEmptyForNewRobot":
                    return FailedQueueItemDtoErrorCode.CredentialAssetEmptyForNewRobot;
                case "AssetTypeNonUpdatable":
                    return FailedQueueItemDtoErrorCode.AssetTypeNonUpdatable;
                case "AssetNotAvailableForRobot":
                    return FailedQueueItemDtoErrorCode.AssetNotAvailableForRobot;
                case "InvalidCron":
                    return FailedQueueItemDtoErrorCode.InvalidCron;
                case "ScheduleWillNeverRun":
                    return FailedQueueItemDtoErrorCode.ScheduleWillNeverRun;
                case "ScheduleMisfired":
                    return FailedQueueItemDtoErrorCode.ScheduleMisfired;
                case "ScheduleInvalidTimeZone":
                    return FailedQueueItemDtoErrorCode.ScheduleInvalidTimeZone;
                case "InvalidScheduleKey":
                    return FailedQueueItemDtoErrorCode.InvalidScheduleKey;
                case "ScheduleIsNotEnabled":
                    return FailedQueueItemDtoErrorCode.ScheduleIsNotEnabled;
                case "ScheduleNotAssociatedWithAQueue":
                    return FailedQueueItemDtoErrorCode.ScheduleNotAssociatedWithAQueue;
                case "ScheduleCannotBeAssociatedWithAQueue":
                    return FailedQueueItemDtoErrorCode.ScheduleCannotBeAssociatedWithAQueue;
                case "UserIsAssignedToTriggers":
                    return FailedQueueItemDtoErrorCode.UserIsAssignedToTriggers;
                case "DownloadUnavailable":
                    return FailedQueueItemDtoErrorCode.DownloadUnavailable;
                case "CannotConnectToPackagesRepository":
                    return FailedQueueItemDtoErrorCode.CannotConnectToPackagesRepository;
                case "NotSupportedByExternalFeeds":
                    return FailedQueueItemDtoErrorCode.NotSupportedByExternalFeeds;
                case "ErrorDownloading":
                    return FailedQueueItemDtoErrorCode.ErrorDownloading;
                case "InvalidPackageDetails":
                    return FailedQueueItemDtoErrorCode.InvalidPackageDetails;
                case "TenantFeedInUse":
                    return FailedQueueItemDtoErrorCode.TenantFeedInUse;
                case "InvalidProcessKey":
                    return FailedQueueItemDtoErrorCode.InvalidProcessKey;
                case "JobTypeCannotBeStopped":
                    return FailedQueueItemDtoErrorCode.JobTypeCannotBeStopped;
                case "JobCannotBeCancelled":
                    return FailedQueueItemDtoErrorCode.JobCannotBeCancelled;
                case "JobCannotBeTerminated":
                    return FailedQueueItemDtoErrorCode.JobCannotBeTerminated;
                case "VersionNotFound":
                    return FailedQueueItemDtoErrorCode.VersionNotFound;
                case "ProcessNotFound":
                    return FailedQueueItemDtoErrorCode.ProcessNotFound;
                case "HasAttachedProcesses":
                    return FailedQueueItemDtoErrorCode.HasAttachedProcesses;
                case "InvalidExtension":
                    return FailedQueueItemDtoErrorCode.InvalidExtension;
                case "InvalidPackageCount":
                    return FailedQueueItemDtoErrorCode.InvalidPackageCount;
                case "PreviousVersionNotFound":
                    return FailedQueueItemDtoErrorCode.PreviousVersionNotFound;
                case "HasRunningJobs":
                    return FailedQueueItemDtoErrorCode.HasRunningJobs;
                case "TenantNotFound":
                    return FailedQueueItemDtoErrorCode.TenantNotFound;
                case "PendingJobsAlreadyExist":
                    return FailedQueueItemDtoErrorCode.PendingJobsAlreadyExist;
                case "InvalidStartJobRobotIds":
                    return FailedQueueItemDtoErrorCode.InvalidStartJobRobotIds;
                case "UnregisteredCannotStartJobs":
                    return FailedQueueItemDtoErrorCode.UnregisteredCannotStartJobs;
                case "LicenseExpiredCannotStartJobs":
                    return FailedQueueItemDtoErrorCode.LicenseExpiredCannotStartJobs;
                case "InvalidReleaseKey":
                    return FailedQueueItemDtoErrorCode.InvalidReleaseKey;
                case "InvalidPackageVersion":
                    return FailedQueueItemDtoErrorCode.InvalidPackageVersion;
                case "TenantIsDisabled":
                    return FailedQueueItemDtoErrorCode.TenantIsDisabled;
                case "PackageNotFound":
                    return FailedQueueItemDtoErrorCode.PackageNotFound;
                case "NoRobotsAvailable":
                    return FailedQueueItemDtoErrorCode.NoRobotsAvailable;
                case "PathTooLong":
                    return FailedQueueItemDtoErrorCode.PathTooLong;
                case "JobExecutionFaulted":
                    return FailedQueueItemDtoErrorCode.JobExecutionFaulted;
                case "InvalidJobIdOrRobotKey":
                    return FailedQueueItemDtoErrorCode.InvalidJobIdOrRobotKey;
                case "InvalidJobStateForSuspend":
                    return FailedQueueItemDtoErrorCode.InvalidJobStateForSuspend;
                case "JobNotFoundByPersistenceId":
                    return FailedQueueItemDtoErrorCode.JobNotFoundByPersistenceId;
                case "ErrorPackagePublish":
                    return FailedQueueItemDtoErrorCode.ErrorPackagePublish;
                case "ErrorSavingPackageDefinition":
                    return FailedQueueItemDtoErrorCode.ErrorSavingPackageDefinition;
                case "MaxNumberJobsAlreadyExist":
                    return FailedQueueItemDtoErrorCode.MaxNumberJobsAlreadyExist;
                case "HasSlaEnabedQueuesAssociated":
                    return FailedQueueItemDtoErrorCode.HasSlaEnabedQueuesAssociated;
                case "VersionsManagedAutomatically":
                    return FailedQueueItemDtoErrorCode.VersionsManagedAutomatically;
                case "InaccessibleFeed":
                    return FailedQueueItemDtoErrorCode.InaccessibleFeed;
                case "TestAutomationJobExecutionNotSupported":
                    return FailedQueueItemDtoErrorCode.TestAutomationJobExecutionNotSupported;
                case "TestAutomationProcessAlreadyExists":
                    return FailedQueueItemDtoErrorCode.TestAutomationProcessAlreadyExists;
                case "CyberArkEditPasswordNotAllowed":
                    return FailedQueueItemDtoErrorCode.CyberArkEditPasswordNotAllowed;
                case "LogMessageNotFound":
                    return FailedQueueItemDtoErrorCode.LogMessageNotFound;
                case "LogRobotNameNotFound":
                    return FailedQueueItemDtoErrorCode.LogRobotNameNotFound;
                case "EncryptionKeyNotFound":
                    return FailedQueueItemDtoErrorCode.EncryptionKeyNotFound;
                case "EncryptionKeyIncorrectFormat":
                    return FailedQueueItemDtoErrorCode.EncryptionKeyIncorrectFormat;
                case "AzureKeyVaultRetrieveIssue":
                    return FailedQueueItemDtoErrorCode.AzureKeyVaultRetrieveIssue;
                case "AzureKeyVaultStoreIssue":
                    return FailedQueueItemDtoErrorCode.AzureKeyVaultStoreIssue;
                case "TransactionReferenceRequired":
                    return FailedQueueItemDtoErrorCode.TransactionReferenceRequired;
                case "InvalidTransactionProgressStatus":
                    return FailedQueueItemDtoErrorCode.InvalidTransactionProgressStatus;
                case "TransactionNotStarted":
                    return FailedQueueItemDtoErrorCode.TransactionNotStarted;
                case "ReviewerNotAvailable":
                    return FailedQueueItemDtoErrorCode.ReviewerNotAvailable;
                case "QueueDefinitionParametersCannotChange":
                    return FailedQueueItemDtoErrorCode.QueueDefinitionParametersCannotChange;
                case "QueueProcessingApplicationException":
                    return FailedQueueItemDtoErrorCode.QueueProcessingApplicationException;
                case "QueueItemSchemaViolationException":
                    return FailedQueueItemDtoErrorCode.QueueItemSchemaViolationException;
                case "InvalidQueueSchemaDefinition":
                    return FailedQueueItemDtoErrorCode.InvalidQueueSchemaDefinition;
                case "InvalidQueueSchemaDefinitionChange":
                    return FailedQueueItemDtoErrorCode.InvalidQueueSchemaDefinitionChange;
                case "InvalidQueueSchemaType":
                    return FailedQueueItemDtoErrorCode.InvalidQueueSchemaType;
                case "QueueSchemaDefinitionNotFound":
                    return FailedQueueItemDtoErrorCode.QueueSchemaDefinitionNotFound;
                case "SlaEnableQueueDefinitionFailure":
                    return FailedQueueItemDtoErrorCode.SlaEnableQueueDefinitionFailure;
                case "QueueSlaAtPredictedRisk":
                    return FailedQueueItemDtoErrorCode.QueueSlaAtPredictedRisk;
                case "QueueSlaPredictedBreach":
                    return FailedQueueItemDtoErrorCode.QueueSlaPredictedBreach;
                case "QueueItemContentSizeExceeded":
                    return FailedQueueItemDtoErrorCode.QueueItemContentSizeExceeded;
                case "LicenseNotFound":
                    return FailedQueueItemDtoErrorCode.LicenseNotFound;
                case "LicenseExpired":
                    return FailedQueueItemDtoErrorCode.LicenseExpired;
                case "LicenseAlreadyInUse":
                    return FailedQueueItemDtoErrorCode.LicenseAlreadyInUse;
                case "InvalidLicenseFormat":
                    return FailedQueueItemDtoErrorCode.InvalidLicenseFormat;
                case "LicenseLimitExceeded":
                    return FailedQueueItemDtoErrorCode.LicenseLimitExceeded;
                case "UnattendedLicenseLimitExceeded":
                    return FailedQueueItemDtoErrorCode.UnattendedLicenseLimitExceeded;
                case "NonProductionLicenseLimitExceeded":
                    return FailedQueueItemDtoErrorCode.NonProductionLicenseLimitExceeded;
                case "AttendedLicenseLimitExceeded":
                    return FailedQueueItemDtoErrorCode.AttendedLicenseLimitExceeded;
                case "DevelopmentLicenseLimitExceeded":
                    return FailedQueueItemDtoErrorCode.DevelopmentLicenseLimitExceeded;
                case "RobotFailedToAcquireLicense":
                    return FailedQueueItemDtoErrorCode.RobotFailedToAcquireLicense;
                case "NonProductionSlotsLimitExceeded":
                    return FailedQueueItemDtoErrorCode.NonProductionSlotsLimitExceeded;
                case "UnattendedSlotsLimitExceeded":
                    return FailedQueueItemDtoErrorCode.UnattendedSlotsLimitExceeded;
                case "LicenseUnregistered":
                    return FailedQueueItemDtoErrorCode.LicenseUnregistered;
                case "LicenseNotAvailable":
                    return FailedQueueItemDtoErrorCode.LicenseNotAvailable;
                case "NotEnoughAvailableSlots":
                    return FailedQueueItemDtoErrorCode.NotEnoughAvailableSlots;
                case "NotEnoughRuntimeLicenses":
                    return FailedQueueItemDtoErrorCode.NotEnoughRuntimeLicenses;
                case "SlotsExceedLicenseLimit":
                    return FailedQueueItemDtoErrorCode.SlotsExceedLicenseLimit;
                case "NotEnoughAvailableLicenses":
                    return FailedQueueItemDtoErrorCode.NotEnoughAvailableLicenses;
                case "HostLicenseLimitExceeded":
                    return FailedQueueItemDtoErrorCode.HostLicenseLimitExceeded;
                case "NoHostLicense":
                    return FailedQueueItemDtoErrorCode.NoHostLicense;
                case "LicenseNewInvalidArguments":
                    return FailedQueueItemDtoErrorCode.LicenseNewInvalidArguments;
                case "LicenseMachineDisabled":
                    return FailedQueueItemDtoErrorCode.LicenseMachineDisabled;
                case "CannotDisableBusyMachine":
                    return FailedQueueItemDtoErrorCode.CannotDisableBusyMachine;
                case "HeadlessSlotsLimitExceeded":
                    return FailedQueueItemDtoErrorCode.HeadlessSlotsLimitExceeded;
                case "HeadlessLicenseLimitExceeded":
                    return FailedQueueItemDtoErrorCode.HeadlessLicenseLimitExceeded;
                case "TestAutomationSlotsLimitExceeded":
                    return FailedQueueItemDtoErrorCode.TestAutomationSlotsLimitExceeded;
                case "TestAutomationLicenseLimitExceeded":
                    return FailedQueueItemDtoErrorCode.TestAutomationLicenseLimitExceeded;
                case "ArgumentMetadataExtract":
                    return FailedQueueItemDtoErrorCode.ArgumentMetadataExtract;
                case "ArgumentMetadataValidation":
                    return FailedQueueItemDtoErrorCode.ArgumentMetadataValidation;
                case "ArgumentDefinitionExtract":
                    return FailedQueueItemDtoErrorCode.ArgumentDefinitionExtract;
                case "ArgumentValueExtract":
                    return FailedQueueItemDtoErrorCode.ArgumentValueExtract;
                case "ArgumentValidation":
                    return FailedQueueItemDtoErrorCode.ArgumentValidation;
                case "PackageMetadataExtract":
                    return FailedQueueItemDtoErrorCode.PackageMetadataExtract;
                case "PackageMetadataValidation":
                    return FailedQueueItemDtoErrorCode.PackageMetadataValidation;
                case "ProjectTypeChangedOnUpload":
                    return FailedQueueItemDtoErrorCode.ProjectTypeChangedOnUpload;
                case "EntryPointUniqueIdsAlreadyUsed":
                    return FailedQueueItemDtoErrorCode.EntryPointUniqueIdsAlreadyUsed;
                case "UnknownWebhookEventType":
                    return FailedQueueItemDtoErrorCode.UnknownWebhookEventType;
                case "WebhookQuotaReached":
                    return FailedQueueItemDtoErrorCode.WebhookQuotaReached;
                case "ExecutionMediaStorageUnavailable":
                    return FailedQueueItemDtoErrorCode.ExecutionMediaStorageUnavailable;
                case "ExecutionMediaNotAvailableForJob":
                    return FailedQueueItemDtoErrorCode.ExecutionMediaNotAvailableForJob;
                case "ExecutionMediaContentNotAvailable":
                    return FailedQueueItemDtoErrorCode.ExecutionMediaContentNotAvailable;
                case "CannotDeleteDefaultCredentialStore":
                    return FailedQueueItemDtoErrorCode.CannotDeleteDefaultCredentialStore;
                case "CredentialStoreNotFound":
                    return FailedQueueItemDtoErrorCode.CredentialStoreNotFound;
                case "UnknownCredentialStoreType":
                    return FailedQueueItemDtoErrorCode.UnknownCredentialStoreType;
                case "InvalidCredentialStoreConfiguration":
                    return FailedQueueItemDtoErrorCode.InvalidCredentialStoreConfiguration;
                case "FailedToReadFromCredentialStore":
                    return FailedQueueItemDtoErrorCode.FailedToReadFromCredentialStore;
                case "FailedToWriteToCredentialStore":
                    return FailedQueueItemDtoErrorCode.FailedToWriteToCredentialStore;
                case "CannotDeleteNonEmptyCredentialStore":
                    return FailedQueueItemDtoErrorCode.CannotDeleteNonEmptyCredentialStore;
                case "ContentLengthTooLarge":
                    return FailedQueueItemDtoErrorCode.ContentLengthTooLarge;
                case "TaskAssignmentError":
                    return FailedQueueItemDtoErrorCode.TaskAssignmentError;
                case "TaskCompletionError":
                    return FailedQueueItemDtoErrorCode.TaskCompletionError;
                case "TaskAssigneeMismatchError":
                    return FailedQueueItemDtoErrorCode.TaskAssigneeMismatchError;
                case "TaskFormInvalidFormLayout":
                    return FailedQueueItemDtoErrorCode.TaskFormInvalidFormLayout;
                case "TaskFormInvalidFormPayload":
                    return FailedQueueItemDtoErrorCode.TaskFormInvalidFormPayload;
                case "TaskFormMultipleActions":
                    return FailedQueueItemDtoErrorCode.TaskFormMultipleActions;
                case "TaskFormNoAction":
                    return FailedQueueItemDtoErrorCode.TaskFormNoAction;
                case "TaskFormInvalidAction":
                    return FailedQueueItemDtoErrorCode.TaskFormInvalidAction;
                case "TasksNotAllowedInModernFolder":
                    return FailedQueueItemDtoErrorCode.TasksNotAllowedInModernFolder;
                case "InvalidSecureStoreContext":
                    return FailedQueueItemDtoErrorCode.InvalidSecureStoreContext;
                case "MailSmtpSettingsError":
                    return FailedQueueItemDtoErrorCode.MailSmtpSettingsError;
                case "CannotDeleteCalendarWhenUsedBySchedule":
                    return FailedQueueItemDtoErrorCode.CannotDeleteCalendarWhenUsedBySchedule;
                case "MandatoryPropertiesForRootFolderNotSpecified":
                    return FailedQueueItemDtoErrorCode.MandatoryPropertiesForRootFolderNotSpecified;
                case "IncompatibleFolderProperties":
                    return FailedQueueItemDtoErrorCode.IncompatibleFolderProperties;
                case "NoHierarchyAllowedForClassicFolders":
                    return FailedQueueItemDtoErrorCode.NoHierarchyAllowedForClassicFolders;
                case "MaximumFolderHierarchyDepthReached":
                    return FailedQueueItemDtoErrorCode.MaximumFolderHierarchyDepthReached;
                case "CannotChangeRobotProvisionType":
                    return FailedQueueItemDtoErrorCode.CannotChangeRobotProvisionType;
                case "CannotChangeFolderPermissionModel":
                    return FailedQueueItemDtoErrorCode.CannotChangeFolderPermissionModel;
                case "CannotEditFolderParent":
                    return FailedQueueItemDtoErrorCode.CannotEditFolderParent;
                case "EntitiesRequiredForAssignmentNotFound":
                    return FailedQueueItemDtoErrorCode.EntitiesRequiredForAssignmentNotFound;
                case "CannotAssignRolesToNonFineGrainedFolders":
                    return FailedQueueItemDtoErrorCode.CannotAssignRolesToNonFineGrainedFolders;
                case "InvalidFolderDisplayName":
                    return FailedQueueItemDtoErrorCode.InvalidFolderDisplayName;
                case "AssociationAlreadyExists":
                    return FailedQueueItemDtoErrorCode.AssociationAlreadyExists;
                case "UserDoesNotHaveAccessToFolder":
                    return FailedQueueItemDtoErrorCode.UserDoesNotHaveAccessToFolder;
                case "CannotChangeRobotUserFolderAssignments":
                    return FailedQueueItemDtoErrorCode.CannotChangeRobotUserFolderAssignments;
                case "CannotAssignMachineToClassicFolder":
                    return FailedQueueItemDtoErrorCode.CannotAssignMachineToClassicFolder;
                case "StrategyNotAvailableInModernFolder":
                    return FailedQueueItemDtoErrorCode.StrategyNotAvailableInModernFolder;
                case "StrategyNotAvailableInClassicFolder":
                    return FailedQueueItemDtoErrorCode.StrategyNotAvailableInClassicFolder;
                case "ValidModernFolderIdRequired":
                    return FailedQueueItemDtoErrorCode.ValidModernFolderIdRequired;
                case "NoMachineAssociatedWithFolder":
                    return FailedQueueItemDtoErrorCode.NoMachineAssociatedWithFolder;
                case "MaintenanceActive":
                    return FailedQueueItemDtoErrorCode.MaintenanceActive;
                case "TenantMaintenanceActive":
                    return FailedQueueItemDtoErrorCode.TenantMaintenanceActive;
                case "TenantMaintenanceNotActive":
                    return FailedQueueItemDtoErrorCode.TenantMaintenanceNotActive;
                case "AnalyticsNotAuthorized":
                    return FailedQueueItemDtoErrorCode.AnalyticsNotAuthorized;
                case "AnalyticsTenantNotProvisioned":
                    return FailedQueueItemDtoErrorCode.AnalyticsTenantNotProvisioned;
                case "AnalyticsUserIsHostUser":
                    return FailedQueueItemDtoErrorCode.AnalyticsUserIsHostUser;
                case "AnalyticsUserHasNoEmail":
                    return FailedQueueItemDtoErrorCode.AnalyticsUserHasNoEmail;
                case "AnalyticsUserNotFound":
                    return FailedQueueItemDtoErrorCode.AnalyticsUserNotFound;
                case "AnalyticsAdminEmailProhibited":
                    return FailedQueueItemDtoErrorCode.AnalyticsAdminEmailProhibited;
                case "InvalidStorageProvider":
                    return FailedQueueItemDtoErrorCode.InvalidStorageProvider;
                case "BucketIsReadOnly":
                    return FailedQueueItemDtoErrorCode.BucketIsReadOnly;
                case "InvalidBlobFilePath":
                    return FailedQueueItemDtoErrorCode.InvalidBlobFilePath;
                case "UnavailableStorageProvider":
                    return FailedQueueItemDtoErrorCode.UnavailableStorageProvider;
                case "TestSetNotNewOnCreate":
                    return FailedQueueItemDtoErrorCode.TestSetNotNewOnCreate;
                case "TestAutomationKeyMismatch":
                    return FailedQueueItemDtoErrorCode.TestAutomationKeyMismatch;
                case "TestSetNewOnUpdate":
                    return FailedQueueItemDtoErrorCode.TestSetNewOnUpdate;
                case "TestSetEmpty":
                    return FailedQueueItemDtoErrorCode.TestSetEmpty;
                case "TestSetDuplicatePackages":
                    return FailedQueueItemDtoErrorCode.TestSetDuplicatePackages;
                case "TestSetVersionMaskInvalid":
                    return FailedQueueItemDtoErrorCode.TestSetVersionMaskInvalid;
                case "TestSetDefinitionNotFound":
                    return FailedQueueItemDtoErrorCode.TestSetDefinitionNotFound;
                case "TestSetTestCaseInvalid":
                    return FailedQueueItemDtoErrorCode.TestSetTestCaseInvalid;
                case "TestSetTestCaseVersionInvalid":
                    return FailedQueueItemDtoErrorCode.TestSetTestCaseVersionInvalid;
                case "TestAutomationVersionInvalid":
                    return FailedQueueItemDtoErrorCode.TestAutomationVersionInvalid;
                case "TestSetExecutionEmptyTestSet":
                    return FailedQueueItemDtoErrorCode.TestSetExecutionEmptyTestSet;
                case "TestSetExecutionCreateFailed":
                    return FailedQueueItemDtoErrorCode.TestSetExecutionCreateFailed;
                case "TestSetExecutionDuplicateUniqueIds":
                    return FailedQueueItemDtoErrorCode.TestSetExecutionDuplicateUniqueIds;
                case "TestCaseAssertionScreenshotMimeTypeMissing":
                    return FailedQueueItemDtoErrorCode.TestCaseAssertionScreenshotMimeTypeMissing;
                case "TestCaseAssertionScreenshotMissing":
                    return FailedQueueItemDtoErrorCode.TestCaseAssertionScreenshotMissing;
                case "InvalidTenantMoveStatus":
                    return FailedQueueItemDtoErrorCode.InvalidTenantMoveStatus;
                case "TenantMoveIdConflict":
                    return FailedQueueItemDtoErrorCode.TenantMoveIdConflict;
                case "TenantMoveMigrationConflict":
                    return FailedQueueItemDtoErrorCode.TenantMoveMigrationConflict;
                case "MediaFileNotFound":
                    return FailedQueueItemDtoErrorCode.MediaFileNotFound;
                case "MediaFileNotFoundForKey":
                    return FailedQueueItemDtoErrorCode.MediaFileNotFoundForKey;
                case "InvalidMediaFilesUpload":
                    return FailedQueueItemDtoErrorCode.InvalidMediaFilesUpload;
                case "MediaFileTypeNotSupported":
                    return FailedQueueItemDtoErrorCode.MediaFileTypeNotSupported;
            }
            return null;
        }
    }
}
